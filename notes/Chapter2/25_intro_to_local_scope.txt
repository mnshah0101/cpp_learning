2.5 Introduction to Local Scope

Variabes defined inside the function body have local scope as opposed to global scope.

Local variables are destroyed in the opposite order of creation at the end of the function body.
An objects lifetime is the duration between creation and destruction.
Objects must be created and initialized no later than the point of definition, and destroyed no earlier than the end of the set of the curly braces in which they are defined (or, for function parameters, at the end of the function).
 In actuality C++ gives the compiler a lot of flexibility as the objects can be deleted before the end of the function scope for optimization.

What happens when an object is destroyed? Not much it just is the end of the object. At some point after descruction it will be deallocated.

Scope defines the identifier that can be seen in that block of code. It is a compiler defined property. in-scope means we can use it and out of scope means we can't use it. An identifier with block scope can be used inside the functions scope.

Out of scope applies to identifier and going out of scope applies to objects that are leaving the scope. A local variableâ€™s lifetime ends at the point where it goes out of scope, so local variables are destroyed at this point.


Functional Seperation:
#include <iostream>

int add(int x, int y) // add's x and y are created and enter scope here
{
    // add's x and y are visible/usable within this function only
    return x + y;
} // add's y and x go out of scope and are destroyed here

int main()
{
    int x{ 5 }; // main's x is created, initialized, and enters scope here
    int y{ 6 }; // main's y is created, initialized, and enters scope here

    // main's x and y are usable within this function only
    std::cout << add(x, y) << '\n'; // calls function add() with x=5 and y=6

    return 0;
} // main's y and x go out of scope and are destroyed here

You can use the same variable names in different functions since they all have block scope.

Where to define variables:

You should define a variable right before its first use. In old C, you could only do at the top of the function but in modern C++, the compilers can handle this for you. This was lifted in C99.

When to use function parameters vs Local variables

Only use function paramters if it needs to be an input into the function, otherwise use local variables.

A temporary object (also sometimes called an anonymous object) is an unnamed object that is used to hold a value that is only needed for a short period of time. Temporary objects are generated by the compiler when they are needed.

#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value of input back to the caller
}

int main()
{
	std::cout << getValueFromUser() << '\n'; // where does the returned value get stored?

	return 0;
}
IN this example a temporary object is created for the getValueFromUser() function call.

Return by value returns a temporary object (that holds a copy of the return value) to the caller.

Temporary objects have no scope at all (this makes sense, since scope is a property of an identifier, and temporary objects have no identifier).

Temporary objects are destroyed at the end of the full expression in which they are created. This means temporary objects are always destroyed before the next statement executes.

In modern C++,   the compiler will often skip creating the temporary and just initialize the variable directly with the return value.

In the above example, the compiler can skip the creation of the temporary object and just put the value returned into the std::cout


